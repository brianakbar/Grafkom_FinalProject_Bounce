"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var mnemonist_1 = require("mnemonist");
var DEFAULT_OPTIONS = {
    bufferDirection: 'FIFO',
    bufferSize: 3,
};
/**
 * Event System class. The class is used to manage events and trigger their handlers.
 */
var EventSystem = /** @class */ (function () {
    /**
     * Event System constructor.
     * @param {EventSystemOptions} options
     * @private
     */
    function EventSystem(options) {
        /**
         * The Event System subscribers.
         * @type {EventSystemSubscriber<E, keyof E>[]}
         * @private
         */
        this.subscribers = [];
        /**
         * The Event System buffer.
         * @type {Map<keyof E, CircularBuffer<Parameters<E[keyof E]>>>}
         * @private
         */
        this.buffer = new Map();
        this.bufferDirection =
            (options === null || options === void 0 ? void 0 : options.bufferDirection) || DEFAULT_OPTIONS.bufferDirection;
        this.bufferSize = (options === null || options === void 0 ? void 0 : options.bufferSize) || DEFAULT_OPTIONS.bufferSize;
    }
    /**
     * Subscribes handler to be called when the event is triggered.
     * @param {K extends keyof E & string} event The event name.
     * @param {(...args: Parameters<E[keyof E]>) => ReturnType<E[keyof E]>} handler The handler function.
     */
    EventSystem.prototype.subscribe = function (event, handler) {
        this.subscribers.push({ event: event, handler: handler });
        if (this.buffer.has(event))
            this.buffer.get(event).forEach(function (args) {
                handler.call.apply(handler, __spreadArray([handler], args, false));
            });
    };
    /**
     * Unsubscribes the handler from the event.
     * @param {K extends keyof E & string} event The event name.
     * @param {(...args: Parameters<E[keyof E]>) => ReturnType<E[keyof E]>} handler The handler function.
     */
    EventSystem.prototype.unsubscribe = function (event, handler) {
        this.subscribers = this.subscribers.filter(function (subscriber) {
            return subscriber.event !== event || subscriber.handler !== handler;
        });
    };
    /**
     * Triggers the event with the given arguments.
     * @param {K extends keyof E & string} event The event name.
     * @param {Parameters<EventSystemEvents[keyof E]>} args The arguments to pass to the handler.
     */
    EventSystem.prototype.notify = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.subscribers.forEach(function (subscriber) {
            var _a;
            if (subscriber.event === event)
                (_a = subscriber.handler).call.apply(_a, __spreadArray([subscriber.handler], args, false));
        });
        if (!this.buffer.has(event))
            this.buffer.set(event, new mnemonist_1.CircularBuffer(Array, this.bufferSize));
        this.buffer
            .get(event)[this.bufferDirection === 'FIFO' ? 'push' : 'unshift'](args);
    };
    return EventSystem;
}());
exports.default = EventSystem;
//# sourceMappingURL=event-system.js.map